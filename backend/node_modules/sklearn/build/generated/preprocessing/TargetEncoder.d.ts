import { PythonBridge, NDArray, ArrayLike } from '@/sklearn/types';
/**
  Target Encoder for regression and classification targets.

  Each category is encoded based on a shrunk estimate of the average target values for observations belonging to the category. The encoding scheme mixes the global target mean with the target mean conditioned on the value of the category. [\[MIC\]](#rf862141e5a0c-mic)

  [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder "sklearn.preprocessing.TargetEncoder") considers missing values, such as `np.nan` or `undefined`, as another category and encodes them like any other category. Categories that are not seen during [`fit`](#sklearn.preprocessing.TargetEncoder.fit "sklearn.preprocessing.TargetEncoder.fit") are encoded with the target mean, i.e. `target\_mean\_`.

  For a demo on the importance of the `TargetEncoder` internal cross-fitting, see ref:`sphx\_glr\_auto\_examples\_preprocessing\_plot\_target\_encoder\_cross\_val.py`. For a comparison of different encoders, refer to [Comparing Target Encoder with Other Encoders](../../auto_examples/preprocessing/plot_target_encoder.html#sphx-glr-auto-examples-preprocessing-plot-target-encoder-py). Read more in the [User Guide](../preprocessing.html#target-encoder).

  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.TargetEncoder.html)
 */
export declare class TargetEncoder {
    id: string;
    opts: any;
    _py: PythonBridge;
    _isInitialized: boolean;
    _isDisposed: boolean;
    constructor(opts?: {
        /**
          Categories (unique values) per feature:
    
          @defaultValue `'auto'`
         */
        categories?: 'auto';
        /**
          Type of target.
    
          @defaultValue `'auto'`
         */
        target_type?: 'auto' | 'continuous' | 'binary';
        /**
          The amount of mixing of the target mean conditioned on the value of the category with the global target mean. A larger `smooth` value will put more weight on the global target mean. If `"auto"`, then `smooth` is set to an empirical Bayes estimate.
    
          @defaultValue `'auto'`
         */
        smooth?: 'auto' | number;
        /**
          Determines the number of folds in the [cross fitting](../../glossary.html#term-0) strategy used in [`fit\_transform`](#sklearn.preprocessing.TargetEncoder.fit_transform "sklearn.preprocessing.TargetEncoder.fit_transform"). For classification targets, `StratifiedKFold` is used and for continuous targets, `KFold` is used.
    
          @defaultValue `5`
         */
        cv?: number;
        /**
          Whether to shuffle the data in [`fit\_transform`](#sklearn.preprocessing.TargetEncoder.fit_transform "sklearn.preprocessing.TargetEncoder.fit_transform") before splitting into folds. Note that the samples within each split will not be shuffled.
    
          @defaultValue `true`
         */
        shuffle?: boolean;
        /**
          When `shuffle` is `true`, `random\_state` affects the ordering of the indices, which controls the randomness of each fold. Otherwise, this parameter has no effect. Pass an int for reproducible output across multiple function calls. See [Glossary](../../glossary.html#term-random_state).
         */
        random_state?: number;
    });
    get py(): PythonBridge;
    set py(pythonBridge: PythonBridge);
    /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
    init(py: PythonBridge): Promise<void>;
    /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
    dispose(): Promise<void>;
    /**
      Fit the [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder "sklearn.preprocessing.TargetEncoder") to X and y.
     */
    fit(opts: {
        /**
          The data to determine the categories of each feature.
         */
        X?: ArrayLike[];
        /**
          The target data used to encode the categories.
         */
        y?: ArrayLike;
    }): Promise<any>;
    /**
      Fit [`TargetEncoder`](#sklearn.preprocessing.TargetEncoder "sklearn.preprocessing.TargetEncoder") and transform X with the target encoding.
     */
    fit_transform(opts: {
        /**
          The data to determine the categories of each feature.
         */
        X?: ArrayLike[];
        /**
          The target data used to encode the categories.
         */
        y?: ArrayLike;
    }): Promise<NDArray[]>;
    /**
      Get output feature names for transformation.
     */
    get_feature_names_out(opts: {
        /**
          Input features.
         */
        input_features?: any;
    }): Promise<any>;
    /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
    get_metadata_routing(opts: {
        /**
          A [`MetadataRequest`](sklearn.utils.metadata_routing.MetadataRequest.html#sklearn.utils.metadata_routing.MetadataRequest "sklearn.utils.metadata_routing.MetadataRequest") encapsulating routing information.
         */
        routing?: any;
    }): Promise<any>;
    /**
      Set output container.
  
      See [Introducing the set\_output API](../../auto_examples/miscellaneous/plot_set_output.html#sphx-glr-auto-examples-miscellaneous-plot-set-output-py) for an example on how to use the API.
     */
    set_output(opts: {
        /**
          Configure output of `transform` and `fit\_transform`.
         */
        transform?: 'default' | 'pandas';
    }): Promise<any>;
    /**
      Transform X with the target encoding.
     */
    transform(opts: {
        /**
          The data to determine the categories of each feature.
         */
        X?: ArrayLike[];
    }): Promise<NDArray[]>;
    /**
      Encodings learnt on all of `X`. For feature `i`, `encodings\_\[i\]` are the encodings matching the categories listed in `categories\_\[i\]`.
     */
    get encodings_(): Promise<any>;
    /**
      The categories of each feature determined during fitting or specified in `categories` (in order of the features in `X` and corresponding with the output of [`transform`](#sklearn.preprocessing.TargetEncoder.transform "sklearn.preprocessing.TargetEncoder.transform")).
     */
    get categories_(): Promise<any>;
    /**
      Type of target.
     */
    get target_type_(): Promise<string>;
    /**
      The overall mean of the target. This value is only used in [`transform`](#sklearn.preprocessing.TargetEncoder.transform "sklearn.preprocessing.TargetEncoder.transform") to encode categories.
     */
    get target_mean_(): Promise<number>;
    /**
      Number of features seen during [fit](../../glossary.html#term-fit).
     */
    get n_features_in_(): Promise<number>;
    /**
      Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
     */
    get feature_names_in_(): Promise<NDArray>;
}
//# sourceMappingURL=TargetEncoder.d.ts.map